/**
 * IntentTracker - 测试意图跟踪器
 * 
 * 记录测试的"意图"而非仅仅是"选择器"
 * 例如：记录"点击登录按钮"而非"点击.btn-primary"
 * 
 * 这使得当DOM变化时，我们可以通过意图重新定位元素
 */

import type { LLMService } from '../llm/LLMService';

export interface TestIntent {
  /** 唯一标识符 */
  id: string;
  
  /** 测试名称 */
  testName: string;
  
  /** 测试文件路径 */
  testFile: string;
  
  /** 意图描述（如"点击登录按钮"） */
  description: string;
  
  /** 操作类型 */
  actionType: ActionType;
  
  /** 原始选择器 */
  originalSelector: string;
  
  /** 元素特征（用于重新识别） */
  elementFeatures: ElementFeatures;
  
  /** 上下文信息 */
  context?: {
    /** 页面URL模式 */
    urlPattern?: string;
    
    /** 前置步骤 */
    previousSteps?: string[];
    
    /** 预期结果 */
    expectedOutcome?: string;
  };
  
  /** 记录时间 */
  recordedAt: Date;
  
  /** 最后验证时间 */
  lastVerifiedAt?: Date;
  
  /** 是否仍然有效 */
  isValid: boolean;
}

export enum ActionType {
  CLICK = 'click',
  FILL = 'fill',
  SELECT = 'select',
  CHECK = 'check',
  NAVIGATE = 'navigate',
  WAIT = 'wait',
  ASSERT = 'assert',
  OTHER = 'other'
}

export interface ElementFeatures {
  /** 文本内容 */
  textContent?: string;
  
  /** 标签名 */
  tagName?: string;
  
  /** 类名 */
  classNames?: string[];
  
  /** 属性 */
  attributes?: Record<string, string>;
  
  /** 位置信息（相对父元素） */
  position?: {
    index: number;
    parent?: string;
  };
  
  /** 视觉特征（颜色、大小等） */
  visualFeatures?: {
    backgroundColor?: string;
    textColor?: string;
    fontSize?: string;
    dimensions?: { width: number; height: number };
  };
  
  /** 周围元素（用于上下文） */
  nearbyElements?: string[];
}

export interface IntentRecordOptions {
  /** 是否记录视觉特征 */
  includeVisualFeatures?: boolean;
  
  /** 是否记录周围元素 */
  includeNearbyElements?: boolean;
  
  /** 自动提取意图描述 */
  autoGenerateDescription?: boolean;
}

/**
 * 意图跟踪器
 */
export class IntentTracker {
  private intents: Map<string, TestIntent> = new Map();
  private llmService?: LLMService;

  constructor(llmService?: LLMService) {
    this.llmService = llmService;
  }

  /**
   * 记录测试意图
   */
  async recordIntent(
    testName: string,
    testFile: string,
    actionType: ActionType,
    selector: string,
    element: any, // 实际DOM元素
    options: IntentRecordOptions = {}
  ): Promise<TestIntent> {
    const {
      includeVisualFeatures = false,
      includeNearbyElements = true,
      autoGenerateDescription = true
    } = options;

    // 提取元素特征
    const features = await this.extractElementFeatures(
      element,
      includeVisualFeatures,
      includeNearbyElements
    );

    // 生成意图描述
    let description = `${actionType} on ${selector}`;
    if (autoGenerateDescription && this.llmService) {
      description = await this.generateIntentDescription(
        actionType,
        features,
        selector
      );
    } else {
      // 基于规则生成描述
      description = this.generateRuleBasedDescription(actionType, features);
    }

    const intent: TestIntent = {
      id: this.generateIntentId(testName, actionType, selector),
      testName,
      testFile,
      description,
      actionType,
      originalSelector: selector,
      elementFeatures: features,
      recordedAt: new Date(),
      isValid: true
    };

    this.intents.set(intent.id, intent);
    
    return intent;
  }

  /**
   * 查找匹配的意图
   */
  findIntent(
    testName: string,
    selector: string
  ): TestIntent | undefined {
    for (const intent of this.intents.values()) {
      if (intent.testName === testName && 
          intent.originalSelector === selector &&
          intent.isValid) {
        return intent;
      }
    }
    return undefined;
  }

  /**
   * 通过意图重新定位元素
   */
  async relocateByIntent(
    intent: TestIntent,
    currentPage: any // 当前页面上下文
  ): Promise<{
    element: any;
    newSelector: string;
    confidence: number;
  } | null> {
    // 策略1: 尝试使用原始选择器
    let element = await this.tryOriginalSelector(intent, currentPage);
    if (element) {
      return {
        element,
        newSelector: intent.originalSelector,
        confidence: 1.0
      };
    }

    // 策略2: 基于元素特征查找
    const featureMatch = await this.findByFeatures(intent.elementFeatures, currentPage);
    if (featureMatch) {
      return featureMatch;
    }

    // 策略3: 使用LLM语义理解
    if (this.llmService) {
      const semanticMatch = await this.findBySemanticIntent(intent, currentPage);
      if (semanticMatch) {
        return semanticMatch;
      }
    }

    return null;
  }

  /**
   * 提取元素特征
   */
  private async extractElementFeatures(
    element: any,
    includeVisual: boolean,
    includeNearby: boolean
  ): Promise<ElementFeatures> {
    const features: ElementFeatures = {
      textContent: element.textContent?.trim(),
      tagName: element.tagName?.toLowerCase(),
      classNames: element.className?.split(' ').filter(Boolean),
      attributes: {}
    };

    // 提取关键属性
    const keyAttributes = ['id', 'name', 'type', 'role', 'aria-label', 'data-testid', 'placeholder'];
    for (const attr of keyAttributes) {
      const value = element.getAttribute?.(attr);
      if (value) {
        features.attributes![attr] = value;
      }
    }

    // 提取位置信息
    if (element.parentElement) {
      const siblings = Array.from(element.parentElement.children || []);
      features.position = {
        index: siblings.indexOf(element),
        parent: element.parentElement.tagName?.toLowerCase()
      };
    }

    // 提取视觉特征（如果启用）
    if (includeVisual && element.style) {
      features.visualFeatures = {
        backgroundColor: element.style.backgroundColor,
        textColor: element.style.color,
        fontSize: element.style.fontSize
      };
    }

    // 提取周围元素（如果启用）
    if (includeNearby) {
      features.nearbyElements = this.extractNearbyElements(element);
    }

    return features;
  }

  /**
   * 提取周围元素信息
   */
  private extractNearbyElements(element: any): string[] {
    const nearby: string[] = [];
    
    // 前一个兄弟元素
    if (element.previousElementSibling) {
      nearby.push(`prev:${this.describeElement(element.previousElementSibling)}`);
    }
    
    // 后一个兄弟元素
    if (element.nextElementSibling) {
      nearby.push(`next:${this.describeElement(element.nextElementSibling)}`);
    }
    
    // 父元素
    if (element.parentElement) {
      nearby.push(`parent:${this.describeElement(element.parentElement)}`);
    }
    
    return nearby;
  }

  /**
   * 描述元素（简短形式）
   */
  private describeElement(element: any): string {
    const parts: string[] = [];
    
    if (element.tagName) {
      parts.push(element.tagName.toLowerCase());
    }
    
    if (element.id) {
      parts.push(`#${element.id}`);
    } else if (element.className) {
      const firstClass = element.className.split(' ')[0];
      parts.push(`.${firstClass}`);
    }
    
    if (element.textContent) {
      const text = element.textContent.trim().substring(0, 20);
      if (text) {
        parts.push(`"${text}"`);
      }
    }
    
    return parts.join('');
  }

  /**
   * 生成基于规则的意图描述
   */
  private generateRuleBasedDescription(
    actionType: ActionType,
    features: ElementFeatures
  ): string {
    const parts: string[] = [];

    // 动作
    switch (actionType) {
      case ActionType.CLICK:
        parts.push('Click');
        break;
      case ActionType.FILL:
        parts.push('Fill');
        break;
      case ActionType.SELECT:
        parts.push('Select');
        break;
      case ActionType.CHECK:
        parts.push('Check');
        break;
      default:
        parts.push(actionType);
    }

    // 元素描述
    if (features.attributes?.['aria-label']) {
      parts.push(`"${features.attributes['aria-label']}"`);
    } else if (features.attributes?.['placeholder']) {
      parts.push(`${features.tagName} with placeholder "${features.attributes['placeholder']}"`);
    } else if (features.textContent) {
      parts.push(`"${features.textContent}"`);
    } else if (features.attributes?.['type']) {
      parts.push(`${features.tagName} (${features.attributes['type']})`);
    } else {
      parts.push(features.tagName || 'element');
    }

    return parts.join(' ');
  }

  /**
   * 使用LLM生成意图描述
   */
  private async generateIntentDescription(
    actionType: ActionType,
    features: ElementFeatures,
    selector: string
  ): Promise<string> {
    if (!this.llmService) {
      return this.generateRuleBasedDescription(actionType, features);
    }

    const prompt = `
Generate a concise, human-readable intent description for this test action:

Action Type: ${actionType}
Selector: ${selector}
Element Features:
- Tag: ${features.tagName}
- Text: ${features.textContent || 'none'}
- Attributes: ${JSON.stringify(features.attributes)}
- Classes: ${features.classNames?.join(', ') || 'none'}

Provide a brief description (max 10 words) that describes what the user is trying to do.
Examples:
- "Click login button"
- "Fill email input field"
- "Select country from dropdown"

Output only the description, no explanations.
`;

    try {
      const response = await this.llmService.generate({
        provider: 'openai',
        model: 'gpt-3.5-turbo', // 使用更便宜的模型
        prompt,
        temperature: 0.3,
        maxTokens: 50
      });

      return response.content.trim() || this.generateRuleBasedDescription(actionType, features);
    } catch (error) {
      console.error('Failed to generate intent description:', error);
      return this.generateRuleBasedDescription(actionType, features);
    }
  }

  /**
   * 尝试原始选择器
   */
  private async tryOriginalSelector(
    intent: TestIntent,
    currentPage: any
  ): Promise<any> {
    try {
      // 在真实实现中，这会使用实际的页面API
      // return await currentPage.$(intent.originalSelector);
      
      // 暂时返回模拟
      return null;
    } catch (error) {
      return null;
    }
  }

  /**
   * 基于特征查找元素
   */
  private async findByFeatures(
    features: ElementFeatures,
    currentPage: any
  ): Promise<{
    element: any;
    newSelector: string;
    confidence: number;
  } | null> {
    // 策略：按优先级尝试不同的特征匹配

    // 1. 尝试使用 data-testid
    if (features.attributes?.['data-testid']) {
      const selector = `[data-testid="${features.attributes['data-testid']}"]`;
      const element = await this.queryElement(selector, currentPage);
      if (element) {
        return { element, newSelector: selector, confidence: 0.95 };
      }
    }

    // 2. 尝试使用 ID
    if (features.attributes?.['id']) {
      const selector = `#${features.attributes['id']}`;
      const element = await this.queryElement(selector, currentPage);
      if (element) {
        return { element, newSelector: selector, confidence: 0.9 };
      }
    }

    // 3. 尝试使用 aria-label
    if (features.attributes?.['aria-label']) {
      const selector = `[aria-label="${features.attributes['aria-label']}"]`;
      const element = await this.queryElement(selector, currentPage);
      if (element) {
        return { element, newSelector: selector, confidence: 0.85 };
      }
    }

    // 4. 尝试使用文本内容
    if (features.textContent) {
      // 构造XPath查找文本
      const xpath = `//${features.tagName}[contains(text(), "${features.textContent}")]`;
      const element = await this.queryElementByXPath(xpath, currentPage);
      if (element) {
        return { element, newSelector: xpath, confidence: 0.7 };
      }
    }

    return null;
  }

  /**
   * 使用语义理解查找元素
   */
  private async findBySemanticIntent(
    intent: TestIntent,
    currentPage: any
  ): Promise<{
    element: any;
    newSelector: string;
    confidence: number;
  } | null> {
    if (!this.llmService) {
      return null;
    }

    // TODO: 实现AI语义搜索
    // 这需要：
    // 1. 获取页面所有可交互元素
    // 2. 用LLM评估每个元素是否匹配意图
    // 3. 返回最匹配的元素

    return null;
  }

  /**
   * 查询元素（模拟）
   */
  private async queryElement(selector: string, page: any): Promise<any> {
    // 在真实实现中：
    // return await page.$(selector);
    return null;
  }

  /**
   * 通过XPath查询元素（模拟）
   */
  private async queryElementByXPath(xpath: string, page: any): Promise<any> {
    // 在真实实现中：
    // return await page.$x(xpath);
    return null;
  }

  /**
   * 生成意图ID
   */
  private generateIntentId(testName: string, action: ActionType, selector: string): string {
    const hash = `${testName}:${action}:${selector}`;
    return Buffer.from(hash).toString('base64').substring(0, 16);
  }

  /**
   * 更新意图状态
   */
  updateIntentStatus(intentId: string, isValid: boolean): void {
    const intent = this.intents.get(intentId);
    if (intent) {
      intent.isValid = isValid;
      intent.lastVerifiedAt = new Date();
    }
  }

  /**
   * 获取所有意图
   */
  getAllIntents(): TestIntent[] {
    return Array.from(this.intents.values());
  }

  /**
   * 获取测试的所有意图
   */
  getIntentsForTest(testName: string): TestIntent[] {
    return Array.from(this.intents.values()).filter(
      intent => intent.testName === testName && intent.isValid
    );
  }

  /**
   * 清除无效意图
   */
  clearInvalidIntents(): number {
    const invalidIntents = Array.from(this.intents.entries())
      .filter(([_, intent]) => !intent.isValid);
    
    for (const [id, _] of invalidIntents) {
      this.intents.delete(id);
    }
    
    return invalidIntents.length;
  }

  /**
   * 导出意图数据（用于持久化）
   */
  exportIntents(): string {
    const data = Array.from(this.intents.values());
    return JSON.stringify(data, null, 2);
  }

  /**
   * 导入意图数据
   */
  importIntents(jsonData: string): number {
    try {
      const data = JSON.parse(jsonData) as TestIntent[];
      let imported = 0;
      
      for (const intent of data) {
        // 恢复Date对象
        intent.recordedAt = new Date(intent.recordedAt);
        if (intent.lastVerifiedAt) {
          intent.lastVerifiedAt = new Date(intent.lastVerifiedAt);
        }
        
        this.intents.set(intent.id, intent);
        imported++;
      }
      
      return imported;
    } catch (error) {
      console.error('Failed to import intents:', error);
      return 0;
    }
  }
}

/**
 * 便捷工厂函数
 */
export function createIntentTracker(llmService?: LLMService): IntentTracker {
  return new IntentTracker(llmService);
}

