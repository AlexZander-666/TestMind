/**
 * IntentTracker单元测试
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { IntentTracker, ActionType, type TestIntent, type ElementFeatures } from '../IntentTracker';
import type { LLMService } from '../../llm/LLMService';

describe('IntentTracker', () => {
  let tracker: IntentTracker;
  let mockLLMService: LLMService;

  beforeEach(() => {
    // Mock LLM Service
    mockLLMService = {
      generate: vi.fn().mockResolvedValue({
        content: 'Click submit button',
        usage: { totalTokens: 20 }
      })
    } as any;

    tracker = new IntentTracker(mockLLMService);
  });

  describe('recordIntent', () => {
    it('should record click intent with complete element features', async () => {
      const mockElement = {
        textContent: 'Submit',
        tagName: 'BUTTON',
        className: 'btn btn-primary',
        getAttribute: (name: string) => {
          if (name === 'data-testid') return 'submit-btn';
          if (name === 'type') return 'submit';
          return null;
        },
        parentElement: {
          tagName: 'FORM',
          children: [{}, {}, {}]
        },
        previousElementSibling: null,
        nextElementSibling: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '.btn-primary',
        mockElement,
        { autoGenerateDescription: false }
      );

      expect(intent).toBeDefined();
      expect(intent.testName).toBe('login-test');
      expect(intent.actionType).toBe(ActionType.CLICK);
      expect(intent.originalSelector).toBe('.btn-primary');
      expect(intent.elementFeatures.textContent).toBe('Submit');
      expect(intent.elementFeatures.tagName).toBe('button');
      expect(intent.elementFeatures.attributes?.['data-testid']).toBe('submit-btn');
      expect(intent.isValid).toBe(true);
    });

    it('should auto-generate intent description using LLM', async () => {
      const mockElement = {
        textContent: 'Login',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '#login-btn',
        mockElement,
        { autoGenerateDescription: true }
      );

      expect(mockLLMService.generate).toHaveBeenCalled();
      expect(intent.description).toBe('Click submit button');
    });

    it('should generate rule-based description when LLM unavailable', async () => {
      const trackerNoLLM = new IntentTracker();
      
      const mockElement = {
        textContent: 'Submit Form',
        tagName: 'BUTTON',
        getAttribute: (name: string) => name === 'aria-label' ? 'Submit button' : null,
        parentElement: null,
        style: {}
      };

      const intent = await trackerNoLLM.recordIntent(
        'form-test',
        'tests/form.test.ts',
        ActionType.CLICK,
        'button',
        mockElement
      );

      expect(intent.description).toContain('Click');
      expect(intent.description).toContain('Submit button');
    });

    it('should extract nearby elements for context', async () => {
      const prevElement = {
        tagName: 'INPUT',
        id: 'email',
        textContent: ''
      };

      const nextElement = {
        tagName: 'A',
        className: 'forgot-password',
        textContent: 'Forgot password?'
      };

      const mockElement = {
        textContent: 'Login',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: {
          tagName: 'FORM',
          children: []
        },
        previousElementSibling: prevElement,
        nextElementSibling: nextElement,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '#login',
        mockElement,
        { includeNearbyElements: true }
      );

      expect(intent.elementFeatures.nearbyElements).toBeDefined();
      expect(intent.elementFeatures.nearbyElements?.length).toBeGreaterThan(0);
      expect(intent.elementFeatures.nearbyElements?.some(e => e.includes('email'))).toBe(true);
    });
  });

  describe('findIntent', () => {
    it('should find intent by test name and selector', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent(
        'my-test',
        'test.ts',
        ActionType.CLICK,
        '.my-selector',
        mockElement
      );

      const found = tracker.findIntent('my-test', '.my-selector');

      expect(found).toBeDefined();
      expect(found?.testName).toBe('my-test');
      expect(found?.originalSelector).toBe('.my-selector');
    });

    it('should return undefined for non-existent intent', () => {
      const found = tracker.findIntent('non-existent', '.selector');
      expect(found).toBeUndefined();
    });

    it('should not return invalid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent(
        'test-name',
        'test.ts',
        ActionType.CLICK,
        '.selector',
        mockElement
      );

      // 标记为invalid
      const allIntents = tracker.getAllIntents();
      const intentId = allIntents[0].id;
      tracker.updateIntentStatus(intentId, false);

      const found = tracker.findIntent('test-name', '.selector');
      expect(found).toBeUndefined(); // 不应该返回invalid的intent
    });
  });

  describe('relocateByIntent', () => {
    it('should relocate element using data-testid', async () => {
      // TODO: 需要mock页面上下文
      // 这个测试需要实际的browser/DOM环境或深度mock
    });

    it('should fall back to text content when ID fails', async () => {
      // TODO: 实现完整的relocation测试
    });
  });

  describe('updateIntentStatus', () => {
    it('should update intent validity status', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'test',
        'test.ts',
        ActionType.CLICK,
        '.sel',
        mockElement
      );

      expect(intent.isValid).toBe(true);

      tracker.updateIntentStatus(intent.id, false);
      const updated = tracker.getAllIntents().find(i => i.id === intent.id);

      expect(updated?.isValid).toBe(false);
      expect(updated?.lastVerifiedAt).toBeDefined();
    });
  });

  describe('clearInvalidIntents', () => {
    it('should remove all invalid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      // 创建3个intents
      const intent1 = await tracker.recordIntent('test1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      const intent2 = await tracker.recordIntent('test2', 'test.ts', ActionType.CLICK, '.sel2', mockElement);
      const intent3 = await tracker.recordIntent('test3', 'test.ts', ActionType.CLICK, '.sel3', mockElement);

      // 标记2个为invalid
      tracker.updateIntentStatus(intent1.id, false);
      tracker.updateIntentStatus(intent3.id, false);

      const cleared = tracker.clearInvalidIntents();

      expect(cleared).toBe(2);
      expect(tracker.getAllIntents().length).toBe(1);
      expect(tracker.getAllIntents()[0].id).toBe(intent2.id);
    });
  });

  describe('exportIntents and importIntents', () => {
    it('should export intents to JSON', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent('test', 'test.ts', ActionType.CLICK, '.sel', mockElement);

      const exported = tracker.exportIntents();

      expect(exported).toBeDefined();
      expect(typeof exported).toBe('string');
      
      const parsed = JSON.parse(exported);
      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed.length).toBe(1);
      expect(parsed[0].testName).toBe('test');
    });

    it('should import intents from JSON', async () => {
      const intentData: TestIntent[] = [{
        id: 'test-id',
        testName: 'imported-test',
        testFile: 'test.ts',
        description: 'Click button',
        actionType: ActionType.CLICK,
        originalSelector: '.btn',
        elementFeatures: {
          textContent: 'Click me',
          tagName: 'button'
        },
        recordedAt: new Date(),
        isValid: true
      }];

      const imported = tracker.importIntents(JSON.stringify(intentData));

      expect(imported).toBe(1);
      
      const found = tracker.findIntent('imported-test', '.btn');
      expect(found).toBeDefined();
      expect(found?.description).toBe('Click button');
    });

    it('should handle invalid JSON gracefully', () => {
      const imported = tracker.importIntents('invalid json');
      expect(imported).toBe(0);
    });
  });

  describe('getIntentsForTest', () => {
    it('should return all valid intents for a test', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      await tracker.recordIntent('test-1', 'test.ts', ActionType.FILL, '.sel2', mockElement);
      await tracker.recordIntent('test-2', 'test.ts', ActionType.CLICK, '.sel3', mockElement);

      const intents = tracker.getIntentsForTest('test-1');

      expect(intents.length).toBe(2);
      expect(intents.every(i => i.testName === 'test-1')).toBe(true);
    });

    it('should only return valid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent1 = await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      const intent2 = await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel2', mockElement);

      // 标记一个为invalid
      tracker.updateIntentStatus(intent1.id, false);

      const intents = tracker.getIntentsForTest('test-1');

      expect(intents.length).toBe(1);
      expect(intents[0].id).toBe(intent2.id);
    });
  });
});

 * IntentTracker单元测试
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { IntentTracker, ActionType, type TestIntent, type ElementFeatures } from '../IntentTracker';
import type { LLMService } from '../../llm/LLMService';

describe('IntentTracker', () => {
  let tracker: IntentTracker;
  let mockLLMService: LLMService;

  beforeEach(() => {
    // Mock LLM Service
    mockLLMService = {
      generate: vi.fn().mockResolvedValue({
        content: 'Click submit button',
        usage: { totalTokens: 20 }
      })
    } as any;

    tracker = new IntentTracker(mockLLMService);
  });

  describe('recordIntent', () => {
    it('should record click intent with complete element features', async () => {
      const mockElement = {
        textContent: 'Submit',
        tagName: 'BUTTON',
        className: 'btn btn-primary',
        getAttribute: (name: string) => {
          if (name === 'data-testid') return 'submit-btn';
          if (name === 'type') return 'submit';
          return null;
        },
        parentElement: {
          tagName: 'FORM',
          children: [{}, {}, {}]
        },
        previousElementSibling: null,
        nextElementSibling: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '.btn-primary',
        mockElement,
        { autoGenerateDescription: false }
      );

      expect(intent).toBeDefined();
      expect(intent.testName).toBe('login-test');
      expect(intent.actionType).toBe(ActionType.CLICK);
      expect(intent.originalSelector).toBe('.btn-primary');
      expect(intent.elementFeatures.textContent).toBe('Submit');
      expect(intent.elementFeatures.tagName).toBe('button');
      expect(intent.elementFeatures.attributes?.['data-testid']).toBe('submit-btn');
      expect(intent.isValid).toBe(true);
    });

    it('should auto-generate intent description using LLM', async () => {
      const mockElement = {
        textContent: 'Login',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '#login-btn',
        mockElement,
        { autoGenerateDescription: true }
      );

      expect(mockLLMService.generate).toHaveBeenCalled();
      expect(intent.description).toBe('Click submit button');
    });

    it('should generate rule-based description when LLM unavailable', async () => {
      const trackerNoLLM = new IntentTracker();
      
      const mockElement = {
        textContent: 'Submit Form',
        tagName: 'BUTTON',
        getAttribute: (name: string) => name === 'aria-label' ? 'Submit button' : null,
        parentElement: null,
        style: {}
      };

      const intent = await trackerNoLLM.recordIntent(
        'form-test',
        'tests/form.test.ts',
        ActionType.CLICK,
        'button',
        mockElement
      );

      expect(intent.description).toContain('Click');
      expect(intent.description).toContain('Submit button');
    });

    it('should extract nearby elements for context', async () => {
      const prevElement = {
        tagName: 'INPUT',
        id: 'email',
        textContent: ''
      };

      const nextElement = {
        tagName: 'A',
        className: 'forgot-password',
        textContent: 'Forgot password?'
      };

      const mockElement = {
        textContent: 'Login',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: {
          tagName: 'FORM',
          children: []
        },
        previousElementSibling: prevElement,
        nextElementSibling: nextElement,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '#login',
        mockElement,
        { includeNearbyElements: true }
      );

      expect(intent.elementFeatures.nearbyElements).toBeDefined();
      expect(intent.elementFeatures.nearbyElements?.length).toBeGreaterThan(0);
      expect(intent.elementFeatures.nearbyElements?.some(e => e.includes('email'))).toBe(true);
    });
  });

  describe('findIntent', () => {
    it('should find intent by test name and selector', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent(
        'my-test',
        'test.ts',
        ActionType.CLICK,
        '.my-selector',
        mockElement
      );

      const found = tracker.findIntent('my-test', '.my-selector');

      expect(found).toBeDefined();
      expect(found?.testName).toBe('my-test');
      expect(found?.originalSelector).toBe('.my-selector');
    });

    it('should return undefined for non-existent intent', () => {
      const found = tracker.findIntent('non-existent', '.selector');
      expect(found).toBeUndefined();
    });

    it('should not return invalid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent(
        'test-name',
        'test.ts',
        ActionType.CLICK,
        '.selector',
        mockElement
      );

      // 标记为invalid
      const allIntents = tracker.getAllIntents();
      const intentId = allIntents[0].id;
      tracker.updateIntentStatus(intentId, false);

      const found = tracker.findIntent('test-name', '.selector');
      expect(found).toBeUndefined(); // 不应该返回invalid的intent
    });
  });

  describe('relocateByIntent', () => {
    it('should relocate element using data-testid', async () => {
      // TODO: 需要mock页面上下文
      // 这个测试需要实际的browser/DOM环境或深度mock
    });

    it('should fall back to text content when ID fails', async () => {
      // TODO: 实现完整的relocation测试
    });
  });

  describe('updateIntentStatus', () => {
    it('should update intent validity status', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'test',
        'test.ts',
        ActionType.CLICK,
        '.sel',
        mockElement
      );

      expect(intent.isValid).toBe(true);

      tracker.updateIntentStatus(intent.id, false);
      const updated = tracker.getAllIntents().find(i => i.id === intent.id);

      expect(updated?.isValid).toBe(false);
      expect(updated?.lastVerifiedAt).toBeDefined();
    });
  });

  describe('clearInvalidIntents', () => {
    it('should remove all invalid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      // 创建3个intents
      const intent1 = await tracker.recordIntent('test1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      const intent2 = await tracker.recordIntent('test2', 'test.ts', ActionType.CLICK, '.sel2', mockElement);
      const intent3 = await tracker.recordIntent('test3', 'test.ts', ActionType.CLICK, '.sel3', mockElement);

      // 标记2个为invalid
      tracker.updateIntentStatus(intent1.id, false);
      tracker.updateIntentStatus(intent3.id, false);

      const cleared = tracker.clearInvalidIntents();

      expect(cleared).toBe(2);
      expect(tracker.getAllIntents().length).toBe(1);
      expect(tracker.getAllIntents()[0].id).toBe(intent2.id);
    });
  });

  describe('exportIntents and importIntents', () => {
    it('should export intents to JSON', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent('test', 'test.ts', ActionType.CLICK, '.sel', mockElement);

      const exported = tracker.exportIntents();

      expect(exported).toBeDefined();
      expect(typeof exported).toBe('string');
      
      const parsed = JSON.parse(exported);
      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed.length).toBe(1);
      expect(parsed[0].testName).toBe('test');
    });

    it('should import intents from JSON', async () => {
      const intentData: TestIntent[] = [{
        id: 'test-id',
        testName: 'imported-test',
        testFile: 'test.ts',
        description: 'Click button',
        actionType: ActionType.CLICK,
        originalSelector: '.btn',
        elementFeatures: {
          textContent: 'Click me',
          tagName: 'button'
        },
        recordedAt: new Date(),
        isValid: true
      }];

      const imported = tracker.importIntents(JSON.stringify(intentData));

      expect(imported).toBe(1);
      
      const found = tracker.findIntent('imported-test', '.btn');
      expect(found).toBeDefined();
      expect(found?.description).toBe('Click button');
    });

    it('should handle invalid JSON gracefully', () => {
      const imported = tracker.importIntents('invalid json');
      expect(imported).toBe(0);
    });
  });

  describe('getIntentsForTest', () => {
    it('should return all valid intents for a test', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      await tracker.recordIntent('test-1', 'test.ts', ActionType.FILL, '.sel2', mockElement);
      await tracker.recordIntent('test-2', 'test.ts', ActionType.CLICK, '.sel3', mockElement);

      const intents = tracker.getIntentsForTest('test-1');

      expect(intents.length).toBe(2);
      expect(intents.every(i => i.testName === 'test-1')).toBe(true);
    });

    it('should only return valid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent1 = await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      const intent2 = await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel2', mockElement);

      // 标记一个为invalid
      tracker.updateIntentStatus(intent1.id, false);

      const intents = tracker.getIntentsForTest('test-1');

      expect(intents.length).toBe(1);
      expect(intents[0].id).toBe(intent2.id);
    });
  });
});

 * IntentTracker单元测试
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { IntentTracker, ActionType, type TestIntent, type ElementFeatures } from '../IntentTracker';
import type { LLMService } from '../../llm/LLMService';

describe('IntentTracker', () => {
  let tracker: IntentTracker;
  let mockLLMService: LLMService;

  beforeEach(() => {
    // Mock LLM Service
    mockLLMService = {
      generate: vi.fn().mockResolvedValue({
        content: 'Click submit button',
        usage: { totalTokens: 20 }
      })
    } as any;

    tracker = new IntentTracker(mockLLMService);
  });

  describe('recordIntent', () => {
    it('should record click intent with complete element features', async () => {
      const mockElement = {
        textContent: 'Submit',
        tagName: 'BUTTON',
        className: 'btn btn-primary',
        getAttribute: (name: string) => {
          if (name === 'data-testid') return 'submit-btn';
          if (name === 'type') return 'submit';
          return null;
        },
        parentElement: {
          tagName: 'FORM',
          children: [{}, {}, {}]
        },
        previousElementSibling: null,
        nextElementSibling: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '.btn-primary',
        mockElement,
        { autoGenerateDescription: false }
      );

      expect(intent).toBeDefined();
      expect(intent.testName).toBe('login-test');
      expect(intent.actionType).toBe(ActionType.CLICK);
      expect(intent.originalSelector).toBe('.btn-primary');
      expect(intent.elementFeatures.textContent).toBe('Submit');
      expect(intent.elementFeatures.tagName).toBe('button');
      expect(intent.elementFeatures.attributes?.['data-testid']).toBe('submit-btn');
      expect(intent.isValid).toBe(true);
    });

    it('should auto-generate intent description using LLM', async () => {
      const mockElement = {
        textContent: 'Login',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '#login-btn',
        mockElement,
        { autoGenerateDescription: true }
      );

      expect(mockLLMService.generate).toHaveBeenCalled();
      expect(intent.description).toBe('Click submit button');
    });

    it('should generate rule-based description when LLM unavailable', async () => {
      const trackerNoLLM = new IntentTracker();
      
      const mockElement = {
        textContent: 'Submit Form',
        tagName: 'BUTTON',
        getAttribute: (name: string) => name === 'aria-label' ? 'Submit button' : null,
        parentElement: null,
        style: {}
      };

      const intent = await trackerNoLLM.recordIntent(
        'form-test',
        'tests/form.test.ts',
        ActionType.CLICK,
        'button',
        mockElement
      );

      expect(intent.description).toContain('Click');
      expect(intent.description).toContain('Submit button');
    });

    it('should extract nearby elements for context', async () => {
      const prevElement = {
        tagName: 'INPUT',
        id: 'email',
        textContent: ''
      };

      const nextElement = {
        tagName: 'A',
        className: 'forgot-password',
        textContent: 'Forgot password?'
      };

      const mockElement = {
        textContent: 'Login',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: {
          tagName: 'FORM',
          children: []
        },
        previousElementSibling: prevElement,
        nextElementSibling: nextElement,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'login-test',
        'tests/login.test.ts',
        ActionType.CLICK,
        '#login',
        mockElement,
        { includeNearbyElements: true }
      );

      expect(intent.elementFeatures.nearbyElements).toBeDefined();
      expect(intent.elementFeatures.nearbyElements?.length).toBeGreaterThan(0);
      expect(intent.elementFeatures.nearbyElements?.some(e => e.includes('email'))).toBe(true);
    });
  });

  describe('findIntent', () => {
    it('should find intent by test name and selector', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent(
        'my-test',
        'test.ts',
        ActionType.CLICK,
        '.my-selector',
        mockElement
      );

      const found = tracker.findIntent('my-test', '.my-selector');

      expect(found).toBeDefined();
      expect(found?.testName).toBe('my-test');
      expect(found?.originalSelector).toBe('.my-selector');
    });

    it('should return undefined for non-existent intent', () => {
      const found = tracker.findIntent('non-existent', '.selector');
      expect(found).toBeUndefined();
    });

    it('should not return invalid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent(
        'test-name',
        'test.ts',
        ActionType.CLICK,
        '.selector',
        mockElement
      );

      // 标记为invalid
      const allIntents = tracker.getAllIntents();
      const intentId = allIntents[0].id;
      tracker.updateIntentStatus(intentId, false);

      const found = tracker.findIntent('test-name', '.selector');
      expect(found).toBeUndefined(); // 不应该返回invalid的intent
    });
  });

  describe('relocateByIntent', () => {
    it('should relocate element using data-testid', async () => {
      // TODO: 需要mock页面上下文
      // 这个测试需要实际的browser/DOM环境或深度mock
    });

    it('should fall back to text content when ID fails', async () => {
      // TODO: 实现完整的relocation测试
    });
  });

  describe('updateIntentStatus', () => {
    it('should update intent validity status', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent = await tracker.recordIntent(
        'test',
        'test.ts',
        ActionType.CLICK,
        '.sel',
        mockElement
      );

      expect(intent.isValid).toBe(true);

      tracker.updateIntentStatus(intent.id, false);
      const updated = tracker.getAllIntents().find(i => i.id === intent.id);

      expect(updated?.isValid).toBe(false);
      expect(updated?.lastVerifiedAt).toBeDefined();
    });
  });

  describe('clearInvalidIntents', () => {
    it('should remove all invalid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      // 创建3个intents
      const intent1 = await tracker.recordIntent('test1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      const intent2 = await tracker.recordIntent('test2', 'test.ts', ActionType.CLICK, '.sel2', mockElement);
      const intent3 = await tracker.recordIntent('test3', 'test.ts', ActionType.CLICK, '.sel3', mockElement);

      // 标记2个为invalid
      tracker.updateIntentStatus(intent1.id, false);
      tracker.updateIntentStatus(intent3.id, false);

      const cleared = tracker.clearInvalidIntents();

      expect(cleared).toBe(2);
      expect(tracker.getAllIntents().length).toBe(1);
      expect(tracker.getAllIntents()[0].id).toBe(intent2.id);
    });
  });

  describe('exportIntents and importIntents', () => {
    it('should export intents to JSON', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent('test', 'test.ts', ActionType.CLICK, '.sel', mockElement);

      const exported = tracker.exportIntents();

      expect(exported).toBeDefined();
      expect(typeof exported).toBe('string');
      
      const parsed = JSON.parse(exported);
      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed.length).toBe(1);
      expect(parsed[0].testName).toBe('test');
    });

    it('should import intents from JSON', async () => {
      const intentData: TestIntent[] = [{
        id: 'test-id',
        testName: 'imported-test',
        testFile: 'test.ts',
        description: 'Click button',
        actionType: ActionType.CLICK,
        originalSelector: '.btn',
        elementFeatures: {
          textContent: 'Click me',
          tagName: 'button'
        },
        recordedAt: new Date(),
        isValid: true
      }];

      const imported = tracker.importIntents(JSON.stringify(intentData));

      expect(imported).toBe(1);
      
      const found = tracker.findIntent('imported-test', '.btn');
      expect(found).toBeDefined();
      expect(found?.description).toBe('Click button');
    });

    it('should handle invalid JSON gracefully', () => {
      const imported = tracker.importIntents('invalid json');
      expect(imported).toBe(0);
    });
  });

  describe('getIntentsForTest', () => {
    it('should return all valid intents for a test', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      await tracker.recordIntent('test-1', 'test.ts', ActionType.FILL, '.sel2', mockElement);
      await tracker.recordIntent('test-2', 'test.ts', ActionType.CLICK, '.sel3', mockElement);

      const intents = tracker.getIntentsForTest('test-1');

      expect(intents.length).toBe(2);
      expect(intents.every(i => i.testName === 'test-1')).toBe(true);
    });

    it('should only return valid intents', async () => {
      const mockElement = {
        textContent: 'Test',
        tagName: 'BUTTON',
        getAttribute: () => null,
        parentElement: null,
        style: {}
      };

      const intent1 = await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel1', mockElement);
      const intent2 = await tracker.recordIntent('test-1', 'test.ts', ActionType.CLICK, '.sel2', mockElement);

      // 标记一个为invalid
      tracker.updateIntentStatus(intent1.id, false);

      const intents = tracker.getIntentsForTest('test-1');

      expect(intents.length).toBe(1);
      expect(intents[0].id).toBe(intent2.id);
    });
  });
});

