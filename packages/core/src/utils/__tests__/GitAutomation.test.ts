/**
 * GitAutomation unit tests
 * Testing Git workflow automation
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { GitAutomation } from '../GitAutomation';
import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import { execSync } from 'child_process';

describe('GitAutomation', () => {
  let tempDir: string;
  let gitAutomation: GitAutomation;

  beforeEach(async () => {
    // Create temporary directory
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'testmind-git-test-'));
    
    // Initialize git repo
    try {
      execSync('git init', { cwd: tempDir, stdio: 'ignore' });
      execSync('git config user.email "test@testmind.dev"', { cwd: tempDir, stdio: 'ignore' });
      execSync('git config user.name "TestMind Test"', { cwd: tempDir, stdio: 'ignore' });
      
      // Create initial commit
      await fs.writeFile(path.join(tempDir, 'README.md'), '# Test Repo', 'utf-8');
      execSync('git add .', { cwd: tempDir, stdio: 'ignore' });
      execSync('git commit -m "Initial commit"', { cwd: tempDir, stdio: 'ignore' });
    } catch (error) {
      console.warn('Git initialization failed:', error);
    }

    gitAutomation = new GitAutomation(tempDir);
  });

  afterEach(async () => {
    // Clean up temporary directory
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('isGitRepo', () => {
    it('should detect valid git repository', async () => {
      const isRepo = await gitAutomation.isGitRepo();
      expect(isRepo).toBe(true);
    });

    it('should return false for non-git directory', async () => {
      const nonGitDir = await fs.mkdtemp(path.join(os.tmpdir(), 'non-git-'));
      const nonGitAutomation = new GitAutomation(nonGitDir);
      
      try {
        const isRepo = await nonGitAutomation.isGitRepo();
        expect(isRepo).toBe(false);
      } finally {
        await fs.rm(nonGitDir, { recursive: true, force: true });
      }
    });
  });

  describe('createTestBranch', () => {
    it('should generate valid branch name', async () => {
      const branchName = await gitAutomation.createTestBranch('myFunction');
      
      expect(branchName).toBe('testmind/test-myfunction');
    });

    it('should sanitize function name with special characters', async () => {
      const branchName = await gitAutomation.createTestBranch('MyClass::myMethod');
      
      expect(branchName).toBe('testmind/test-myclass-mymethod');
    });

    it('should use custom prefix', async () => {
      const branchName = await gitAutomation.createTestBranch('func', 'custom/prefix');
      
      expect(branchName).toBe('custom/prefix-func');
    });

    it('should add timestamp suffix if branch exists', async () => {
      // Create a branch
      execSync('git checkout -b testmind/test-duplicate', { cwd: tempDir, stdio: 'ignore' });
      execSync('git checkout main 2>/dev/null || git checkout master', { cwd: tempDir, stdio: 'ignore' });
      
      const branchName = await gitAutomation.createTestBranch('duplicate');
      
      // Should have timestamp suffix
      expect(branchName).toMatch(/^testmind\/test-duplicate-\d+$/);
    });
  });

  describe('generateCommitMessage', () => {
    it('should generate standard commit message', () => {
      const message = GitAutomation.generateCommitMessage({
        functionName: 'createUser',
        filePath: 'src/user-service.ts',
      });

      expect(message).toContain('test: add tests for createUser');
      expect(message).toContain('user-service.ts');
      expect(message).toContain('ðŸ¤– Generated by TestMind');
    });

    it('should include test count if provided', () => {
      const message = GitAutomation.generateCommitMessage({
        functionName: 'calculate',
        filePath: 'src/math.ts',
        testCount: 5,
      });

      expect(message).toContain('Generated 5 test cases');
      expect(message).toContain('calculate()');
    });
  });

  describe('getCurrentBranch', () => {
    it('should return current branch name', async () => {
      const branch = await gitAutomation.getCurrentBranch();
      
      // Should be main or master (depending on git version)
      expect(['main', 'master']).toContain(branch);
    });
  });

  describe('hasUncommittedChanges', () => {
    it('should detect clean working directory', async () => {
      const hasChanges = await gitAutomation.hasUncommittedChanges();
      expect(hasChanges).toBe(false);
    });

    it('should detect uncommitted changes', async () => {
      // Create a new file
      await fs.writeFile(path.join(tempDir, 'new-file.ts'), 'content', 'utf-8');
      
      const hasChanges = await gitAutomation.hasUncommittedChanges();
      expect(hasChanges).toBe(true);
    });
  });

  describe('commitTestChanges', () => {
    it('should create branch and commit test file', async () => {
      const testFile = path.join(tempDir, 'test.test.ts');
      await fs.writeFile(testFile, 'test content', 'utf-8');

      const result = await gitAutomation.commitTestChanges({
        message: 'test: add test',
        files: [testFile],
      });

      expect(result.created).toBe(true);
      expect(result.committed).toBe(true);
      expect(result.branchName).toMatch(/^testmind\/test-/);

      // Verify branch was created
      const currentBranch = await gitAutomation.getCurrentBranch();
      expect(currentBranch).toBe(result.branchName);

      // Verify file was committed
      const hasChanges = await gitAutomation.hasUncommittedChanges();
      expect(hasChanges).toBe(false);
    });

    it('should handle empty files array', async () => {
      await expect(
        gitAutomation.commitTestChanges({
          message: 'test commit',
          files: [],
        })
      ).rejects.toThrow();
    });
  });

  describe('integration scenarios', () => {
    it('should support full workflow: create branch â†’ commit â†’ verify', async () => {
      // 1. Create test file
      const testFile = path.join(tempDir, 'integration.test.ts');
      await fs.writeFile(testFile, 'integration test', 'utf-8');

      // 2. Commit with auto branch
      const result = await gitAutomation.commitTestChanges({
        message: GitAutomation.generateCommitMessage({
          functionName: 'integration',
          filePath: 'integration.ts',
          testCount: 3,
        }),
        files: [testFile],
      });

      // 3. Verify
      expect(result.committed).toBe(true);
      
      const currentBranch = await gitAutomation.getCurrentBranch();
      expect(currentBranch).toBe(result.branchName);
      
      const hasChanges = await gitAutomation.hasUncommittedChanges();
      expect(hasChanges).toBe(false);
    });
  });
});













